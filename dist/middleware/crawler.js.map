{"version":3,"sources":["../../src/middleware/crawler.js"],"names":["pagesToVisit","changedPages","errorPages","brokenLinks","loopCount","bandwidthUsed","PAGE_REG_EXP","TYPE_REG_EXP","crawlPages","req","res","next","pagesToCrawl","i","length","thisPage","url","test","status","visitPages","promises","thisPageToVisit","currentCount","timeout","then","index","requestPage","body","collectLinks","catch","console","log","err","Promise","all","revisedBandwidth","Math","round","toString","pagesCrawled","resolve","reject","setTimeout","pageUrl","currentIndex","wasVisited","indexOf","Error","response","headersMem","headers","bodyMem","date","Date","toTimeString","redirects","request","_redirect","finalRedirect","finalDestination","statusCode","destIsInToVisit","findIndex","page","redirectStatus","pageObj","isInPagesToCrawl","isChanged","$","load","urlObj","domainBaseUrl","hostname","domainRegExp","RegExp","protocol","linkTagsObj","link","linkRef","attr","isAbsolute","revisedLinkRef","replace","linkUrl","linkObj","page_url","link_url","isCorrectLinkType","isCorrectPageType","isCorrectDomain","isInError","isInBroken","toVisitIndex","isInToVisit"],"mappings":"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","file":"crawler.js","sourcesContent":["/* eslint no-loop-func: 0 */\n\nimport request from 'request';\nimport cheerio from 'cheerio';\nimport urlParse from 'url-parse';\nimport sizeof from 'object-sizeof';\n// import heapdump from 'heapdump';\n\n// Arrays for keeping track of page info as the crawler iterates through\n// pages\nlet pagesToVisit = [];\nlet changedPages = [];\nlet errorPages = [];\nlet brokenLinks = [];\nlet loopCount = 0;\nlet bandwidthUsed = 0;\n// RegExps to skip unimportant pages (PAGE_REG_EXP) and not to crawl non-html\n// pages for links (TYPE_REG_EXP), because that results in errors\nconst PAGE_REG_EXP = /permalink|visited-locations|transcripts|news/i;\nconst TYPE_REG_EXP = /\\.zip|\\.doc|\\.ppt|\\.csv|\\.xls|\\.jpg|\\.ash|\\.png|\\.aspx/i;\n\n// Starts the process by building the necessary page arrays\nfunction crawlPages(req, res, next) {\n  const {pagesToCrawl} = req;\n\n  // Loop through existing URLs pulled from Google Sheets,\n  // adding them to 'pagesToVisit' and 'errorPages' arrays\n  for (let i = 0; i < pagesToCrawl.length; i++) {\n    const thisPage = pagesToCrawl[i];\n\n    pagesToVisit[pagesToVisit.length] = thisPage.url;\n\n    if (/40\\d/.test(thisPage.status)) {\n      errorPages[errorPages.length] = thisPage.url;\n    }\n  }\n\n  visitPages(req, res, next);\n}\n\nfunction visitPages(req, res, next) {\n  const promises = [];\n\n  for (loopCount; loopCount < pagesToVisit.length; loopCount++) {\n    const thisPageToVisit = pagesToVisit[loopCount];\n\n    if (thisPageToVisit) {\n      const currentCount = loopCount;\n\n      if (loopCount % 500 === 0) {\n        // heapdump.writeSnapshot((err, filename) => {\n        //   if (err) console.log(err);\n        //   console.log('dump written to', filename);\n        // });\n\n        promises[promises.length] =\n          timeout(thisPageToVisit, currentCount)\n            .then((url, index) => {\n              return requestPage(url, index, req.pagesToCrawl);\n            })\n            .then((url, body) => {\n              if (url && body) {\n                collectLinks(url, body);\n                return 'Links collected';\n              }\n\n              return 'No links';\n            })\n            .catch(err => {\n              console.log(err);\n            }\n          );\n      } else {\n        promises[promises.length] =\n          requestPage(thisPageToVisit, currentCount, req.pagesToCrawl)\n            .then((url, body) => {\n              if (url && body) {\n                collectLinks(url, body);\n                return 'Links collected';\n              }\n\n              return 'No links';\n            })\n            .catch(err => {\n              console.log(err);\n            }\n          );\n      }\n    }\n  }\n\n  Promise.all(promises)\n    .then(results => {\n      console.log(`toCrawl: ${req.pagesToCrawl.length}`,\n        `changed: ${changedPages.length}`,\n        `toVisit: ${pagesToVisit.length}`);\n\n      if (req.pagesToCrawl.length + changedPages.length < pagesToVisit.length) {\n        crawlPages(req, res, next);\n      } else {\n        const revisedBandwidth = bandwidthUsed >= 1000000 ?\n          (Math.round(bandwidthUsed / 10000) / 100).toString() + 'MB' :\n          (Math.round(bandwidthUsed / 10) / 100).toString() + 'KB';\n        console.log(revisedBandwidth);\n        req.pagesCrawled = changedPages;\n        req.brokenLinks = brokenLinks;\n\n        next();\n      }\n    })\n    .catch(err => {\n      console.log(err);\n      next();\n    });\n}\n\nfunction timeout(url, index) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(url, index);\n    }, 0);\n  });\n}\n\n// Makes HTTP requests\nfunction requestPage(pageUrl, currentIndex, pagesToCrawl) {\n  // Only request the page if you haven't visited it yet\n  const wasVisited = pagesToVisit.indexOf(pageUrl) < currentIndex;\n\n  return new Promise((resolve, reject) => {\n    if (pageUrl) {\n      if (wasVisited) {\n        reject(Error('Page was already visited.'));\n      } else {\n        request(pageUrl, (err, response, body) => {\n          const headersMem = sizeof(response.headers);\n          const bodyMem = sizeof(body);\n          bandwidthUsed += headersMem + bodyMem;\n\n          const date = new Date();\n          console.log(currentIndex, date.toTimeString(), pageUrl);\n\n          if (err) {\n            changedPages[changedPages.length] = {\n              url: pageUrl,\n              status: 404\n            };\n            reject(err);\n          } else {\n            const {redirects} = response.request._redirect;\n\n            if (redirects.length) {\n              const finalRedirect = redirects[redirects.length];\n              const finalDestination = finalRedirect &&\n                {url: finalRedirect.url, status: finalRedirect.statusCode};\n              const destIsInToVisit = finalDestination &&\n                pagesToVisit.findIndex(page => {\n                  return finalDestination.url === page.url;\n                }) !== -1;\n\n              if (finalDestination && !destIsInToVisit) {\n                pagesToVisit[pagesToVisit.length] = finalDestination;\n              }\n            }\n\n            const redirectStatus = redirects[0] && redirects[0].statusCode;\n            const status = redirectStatus ?\n              redirectStatus :\n              response.statusCode;\n            const pageObj = {\n              url: pageUrl,\n              status\n            };\n            // If the page doesn't exist on Current URLs sheet,\n            // add it to 'changedPages'\n            const isInPagesToCrawl = pagesToCrawl.findIndex(page => {\n              return page.url === pageObj.url && page.status === pageObj.status;\n            }) !== -1;\n\n            if (!isInPagesToCrawl) {\n              pageObj.isChanged = !isInPagesToCrawl;\n              changedPages[changedPages.length] = pageObj;\n            }\n\n            // If the page is working & the body is html,\n            // collect links for other pages\n            if (!/40\\d/.test(status) && /<?\\/?html>/.test(body)) {\n              resolve(pageUrl, body);\n            } else {\n              resolve();\n            }\n          }\n        });\n      }\n    } else {\n      reject(Error('Page URL is undefined.'));\n    }\n  });\n}\n\n// Scrape page for internal links to add to 'pagesToVisit'\nfunction collectLinks(pageUrl, body) {\n  const $ = cheerio.load(body);\n  const urlObj = new urlParse(pageUrl);\n  const domainBaseUrl = urlObj.hostname;\n  const domainRegExp = new RegExp(domainBaseUrl);\n  const protocol = urlObj.protocol;\n  // Collect URLs from link tags (adding current domain to relative links)\n  const linkTagsObj = $('a[href]');\n\n  for (let i = 0; i < linkTagsObj.length; i++) {\n    const link = linkTagsObj[i];\n    const linkRef = $(link).attr('href');\n    const isAbsolute = /http/i.test(linkRef);\n    const revisedLinkRef = linkRef === '/' ?\n      '' :\n      linkRef.replace(/\\?.*/, '').replace(/#.*/, '').replace(/\\/$/, '');\n    const linkUrl = isAbsolute ?\n      revisedLinkRef :\n      `${protocol}//${domainBaseUrl}${revisedLinkRef}`;\n    const linkObj = {\n      page_url: pageUrl,\n      link_url: linkUrl\n    };\n    const isCorrectLinkType = /^(?:\\/|http)/i.test(revisedLinkRef);\n    const isCorrectPageType =\n      !PAGE_REG_EXP.test(revisedLinkRef) && !TYPE_REG_EXP.test(revisedLinkRef);\n    const isCorrectDomain = isAbsolute ?\n      domainRegExp.test(revisedLinkRef) :\n      true;\n    const isInError = errorPages.indexOf(linkUrl) !== -1;\n    const isInBroken = brokenLinks.findIndex(link => {\n      return link.page_url === pageUrl && link.link_url === linkUrl;\n    }) !== -1;\n    const toVisitIndex = pagesToVisit.indexOf(linkUrl);\n    const isInToVisit = toVisitIndex !== -1;\n\n    if (isCorrectLinkType && isCorrectPageType && isCorrectDomain) {\n      // If the URL is in 'errorPages' and not 'brokenLinks',\n      // add it to 'brokenLinks'\n      if (isInError && !isInBroken) {\n        brokenLinks[brokenLinks.length] = linkObj;\n      // Otherwise, add URL to 'pagesToVisit'\n      } else if (!isInToVisit) {\n        pagesToVisit[pagesToVisit.length] = linkUrl;\n      }\n    }\n  }\n\n  pageUrl = null;\n  body = null;\n}\n\nexport default crawlPages;\n"]}